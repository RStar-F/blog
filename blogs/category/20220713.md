---
title: H5页面阻止滑动滚动穿透
date: 2022-07-13
tags:
 - 疑难杂症
categories: 
 - 笔记
---

在移动端项目开发过程中，如果页面内容过长超过一屏，出现滚动条，当页面上有一个fixed定位的蒙层出现的时候，手指在蒙层上滑动，会看到底部内容也会跟着滚动。

解决办法：

css加入类

```css
.overflow-hidden {
  overflow: hidden;
}
```

js导出两个方法： lock 和 unlock;

```javascript
export default (() => {

  let totalLockCount = 0;

  const BODY_LOCK_CLASS = 'overflow-hidden';

  function isElement(node: Element) {
    return (
      node.tagName !== 'HTML' &&
      node.tagName !== 'BODY' &&
      node.nodeType === 1
    )
  }

  function getScrollParent(el: Element, root: HTMLElement | Window | undefined = window) {
    let node = el
    while (node && node !== root && isElement(node)) {
      const { overflowY } = window.getComputedStyle(node)
      if (/scroll|auto/i.test(overflowY)) {
        return node
      }
      node = node.parentNode as Element
    }
    return root
  }

  function getDirection(x:number, y:number) {
    if (x > y) {
      return 'horizontal';
    }
    if (y > x) {
      return 'vertical';
    }
    return '';
  }

  function useTouch() {
    let touchData = {
      startX: 0,
      startY: 0,
      deltaX: 0,
      deltaY: 0,
      offsetX: 0,
      offsetY: 0,
      direction: '',
      isTap: true,
    }

    const isVertical = () => touchData.direction === 'vertical';
    const isHorizontal = () => touchData.direction === 'horizontal';

    const reset = () => {
      Object.assign(touchData, {
        startX: 0,
        startY: 0,
        deltaX: 0,
        deltaY: 0,
        offsetX: 0,
        offsetY: 0,
        direction: '',
        isTap: true,
      })
    };

    const start = ((event: TouchEvent) => {
      reset();
      touchData.startX = event.touches[0].clientX;
      touchData.startY = event.touches[0].clientY;
    });

    const move = ((event: TouchEvent) => {
      const touch = event.touches[0];
      // safari back will set clientX to negative number
      touchData.deltaX = (touch.clientX < 0 ? 0 : touch.clientX) - touchData.startX;
      touchData.deltaY = touch.clientY - touchData.startY;
      // 横向滑动的距离
      touchData.offsetX = Math.abs(touchData.deltaX);
      // 纵向滑动的距离
      touchData.offsetY = Math.abs(touchData.deltaY);

      // 当距离大于某个值时锁定方向
      const LOCK_DIRECTION_DISTANCE = 10;
      if (
        !touchData.direction ||
        (touchData.offsetX < LOCK_DIRECTION_DISTANCE &&
          touchData.offsetY < LOCK_DIRECTION_DISTANCE)
      ) {
        touchData.direction = getDirection(touchData.offsetX, touchData.offsetY);
      }

      if (
        touchData.isTap &&
        (touchData.offsetX > 5 || touchData.offsetY > 5)
      ) {
        touchData.isTap = false;
      }
    });

    return {
      move,
      start,
      reset,
      isVertical,
      isHorizontal,
      touchData
    };
  }


  function useLockScroll(options?: {
    className?: string;
    root?: any;
  }) {
    const {
      className = BODY_LOCK_CLASS,
      root = window
    } = options || {}
    const touch = useTouch();
    const DIRECTION_UP = '01';
    const DIRECTION_DOWN = '10';

    const onTouchMove = (event:any) => {
      touch.move(event);
      const el = getScrollParent(
        event.target,
        root,
      ) as HTMLElement;

      const direction = touch.touchData.deltaY > 0 ? DIRECTION_DOWN : DIRECTION_UP;
      const { scrollHeight, offsetHeight, scrollTop } = el;
      let status = '11';

      if (scrollTop === 0) {
        status = offsetHeight >= scrollHeight ? '00' : '01';
      } else if (scrollTop + offsetHeight >= scrollHeight) {
        status = '10';
      }

      if (
        status !== '11' &&
        touch.isVertical() &&
        !(parseInt(status, 2) & parseInt(direction, 2))
      ) {
        event.preventDefault()
        event.stopPropagation()
      }
    };

    const lock = () => {
      document.addEventListener('touchstart', touch.start);
      document.addEventListener('touchmove', onTouchMove, { passive: false });

      if (!totalLockCount) {
        document.body.classList.add(className);
      }

      totalLockCount++;
    };

    const unlock = () => {
      if (totalLockCount) {
        document.removeEventListener('touchstart', touch.start);
        document.removeEventListener('touchmove', onTouchMove);

        totalLockCount--;

        if (!totalLockCount) {
          document.body.classList.remove(className);
        }
      }
    };

    // const init = () => shouldLock() && lock();

    // const destroy = () => shouldLock() && unlock();

    return [lock, unlock]
  }

  return useLockScroll
})()
```